#define _CRT_SECURE_NO_WARNINGS 1

#include<stdio.h>

//移位操作符（>>  <<）
//int main()
//{
//	
//	int a = 10;//4个字节-32bit
//	int b = 0;
//	//实质把a的二进制位向右移1位
//	//00000000 00000000 00000000 00001010
//	//移完：00000000 00000000 00000000 00000101
//	b = a >> 1;//5
//	printf("b=%d\n", b);
//	return 0;
//}


//位操作符
//int main()
//{
//	//&  按（二进制位）与
//	int a = 3;  //00000000 00000000 00000000 00000011
//	int b = 4;  //00000000 00000000 00000000 00000100
//	int c = a & b;  //与  00000000 00000000 00000000 00000000  
//	//0
//	printf("与：c = %d\n", c);
//
//	//^  按（二进制位）异或
//	int d = a ^ b;//00000000 00000000 00000000 00000111
//	//7
//	printf("异或：d = %d\n", d);
//
//	//| 按（二进制位）或
//	int e = a | b;//00000000 00000000 00000000 00000111
//	//7
//	printf("或：e = %d\n", e);
//	return 0;
//}


//操作符 ~   对一个数的二进制位按位取反
//整数在内存中存储的是二进制表示的补码
//int main()
//{
//	//正数的原码、反码、补码相同
//	int a = 0;
//	//00000000 00000000 00000000 00000000   //a的补码每位按位取反，在内存中表示二进制的补码，最后在还原原码
//	//a的原码和补码相同 
//	//11111111 11111111 11111111 11111111   //补码
//	//11111111 11111111 11111111 11111110   //反码
//	//10000000 00000000 00000000 00000001   //原码
//    printf("%d\n", ~a);  //-1
//
//	int b = -4;
//	//10000000 00000000 00000000 00000100  //-4原码
//	//11111111 11111111 11111111 11111011  //-4反码
//	//11111111 11111111 11111111 11111100  //-4补码
//	//00000000 00000000 00000000 00000011  //每位按位取反(补码)
//	//最高位为0，为正数，原码补码相同
//	printf("%d\n", ~b);  //3
//	return 0;
//}


//a++ ++a
//int main()
//{
//	//int a = 10;
//	//int b = ++a;
//	////++a  先a+1,后使用a
//	//printf("a = %d   b=%d\n", a,b);  //11 11
//
//	//int a = 10;
//	//int b = a++;
//	////a++ 先使用a的值，在a++
//	//printf("a = %d   b=%d\n", a, b);//11 10
//
//	//int a = 10;
//	//int b = a--;
//	////a--
//	//printf("a = %d   b=%d\n", a, b);//9 10
//
//	//int a = 10;
//	//int b = --a;
//	////--a
//	//printf("a = %d   b=%d\n", a, b); //9 9
//	//return 0;
//}


//赋值=与判断==
//int main()
//{
//	int a = 3;
//	if (a = 4)
//	{
//		printf("hehe\n"); //能打印出来，此时只是赋值
//	}
//	if (a == 3)
//	{
//		printf("hehe\n"); //不能打印，此时是判断，并且此时a为4
//	}
//	return 0;
//}


//逻辑与或
//int main()
//{
//	int a = 3;
//	int b = 0;
//	//int c = a&&b; //逻辑与   1   a=3,b=4
//	int c = a || b;//逻辑或   1     a=3,b=0
//	printf("%d\n", c); //  此时a=3为真，b=4也为真，所以a&&b为真，c就为1
//	return 0;
//}

//逗号表达式
//int main()
//{
//	int a = (3, 4 + 2, 9 + 3, 4 + 3 + 2);//最后一个表达式的结果
//	printf("%d\n", a);//9
//	return 0;
//}


//extern 声明外部符号

//extern int g_gl;
//
//int main()
//{
//	printf("g_gl = %d\n", g_gl); //sum为text1.c文件中的变量
//	return 0;
//}


//register寄存器关键字
//int main()
//{
//	register int a = 10;
//	//若a多次用到，建议把a放入寄存器内
//	//能不能放进去，要看编译器
//	return 0;
//}


//unsigned   signed   typedef

//typedef  signed  int unit;
////signed int 等同于unit，只是换了个说法
//int main()
//{
//	unsigned  int age = 20; 
//	unit sum = 0;
//	return 0;
//}

//static关键字
//1.static修饰局部变量
//改变的是局部变量的生命周期（变长），和程序的生命周期一样

//void test()
//{
//	static int a = 1; //  2，3，4，5，6   和程序的生命周期一样,执行完一次不会销毁，会继续执行
//	//int a = 1;   //结果输出2 2 2 2 2   a为局部变量，等test执行完一次会销毁a，在进来时，就会重新创建a
//	a++;
//	printf("%d ", a);
//}
//int main()
//{
//	int i = 0;
//	//循环5次
//	while (i < 5)
//	{
//		test();
//		i++;
//	}
//	return 0;
//}


//2.static修饰全局变量（全局变量作用域整个工程）
// 改变了这个全局变量的作用域，这个变量只能在自己所在的源文件内部使用
//
//extern int g_gl;
//
//int main()
//{
//	printf("g_gl = %d\n", g_gl);//在text1.c文件中g_gl变量前面加static，就不能再此文件使用
//	return 0;
//}







//3.static修饰函数
//改变了这函数的使用范围，这个函数只能在自己所在的源文件内部使用

extern int Add(int x, int y);//声明外部函数

int main()
{
	int a = 10;
	int b = 10;
	int sum = Add(a, b);
	printf("%d\n", sum);//在text1.c文件Add函数前面加static，就不能再此文件使用
	return 0;
}